<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Laundry! The Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #e0e7ff 0%, #f3e8ff 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .game-container {
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
      padding: 30px;
      max-width: 500px;
      width: 100%;
    }

    h1 {
      text-align: center;
      color: #9333ea;
      font-size: 2em;
      margin-bottom: 20px;
    }

    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .score-info {
      font-weight: bold;
      color: #374151;
    }

    .score {
      color: #9333ea;
      font-size: 1.1em;
    }

    .high-score {
      font-size: 0.9em;
      color: #6b7280;
      margin-top: 4px;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: #9333ea;
      color: white;
    }

    .btn-primary:hover {
      background: #7e22ce;
    }

    .btn-secondary {
      background: #3b82f6;
      color: white;
      font-size: 0.9em;
    }

    .btn-secondary:hover {
      background: #2563eb;
    }

    .message-box {
      padding: 16px;
      border: 2px solid;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 16px;
    }

    .message-box.win {
      background: #d1fae5;
      border-color: #6ee7b7;
    }

    .message-box.lose {
      background: #fee2e2;
      border-color: #fca5a5;
    }

    .message-box.win .title {
      color: #047857;
    }

    .message-box.lose .title {
      color: #b91c1c;
    }

    .message-box .title {
      font-size: 1.3em;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .message-box .score-text {
      color: #374151;
      margin-bottom: 12px;
    }

    .email-form-box {
      padding: 16px;
      background: #faf5ff;
      border: 2px solid #d8b4fe;
      border-radius: 8px;
      margin-bottom: 16px;
    }

    .email-form-box .form-title {
      font-size: 1.1em;
      font-weight: bold;
      color: #6b21a8;
      margin-bottom: 12px;
    }

    .email-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .email-input {
      padding: 10px;
      border: 1px solid #d8b4fe;
      border-radius: 8px;
      font-size: 1em;
    }

    .email-input:focus {
      outline: none;
      border-color: #9333ea;
      box-shadow: 0 0 0 3px rgba(147, 51, 234, 0.1);
    }

    .success-box {
      padding: 16px;
      background: #d1fae5;
      border: 2px solid #6ee7b7;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 16px;
      color: #047857;
      font-weight: bold;
    }

    .instructions {
      padding: 12px;
      background: #eff6ff;
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 0.9em;
      color: #374151;
    }

    .instructions-title {
      font-weight: bold;
      margin-bottom: 6px;
    }

    .instructions p {
      margin: 2px 0;
    }

    #gameCanvas {
      border: 4px solid #d8b4fe;
      border-radius: 8px;
      cursor: crosshair;
      display: block;
      margin: 0 auto;
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>Laundry! The Game</h1>
    
    <div class="score-bar">
      <div class="score-info">
        Score: <span class="score" id="score">0</span>
        <div class="high-score">High: <span id="highScore">0</span></div>
      </div>
      <button class="btn btn-primary" onclick="newGame()">New Game</button>
    </div>

    <div id="gameOverBox" class="message-box hidden">
      <div class="title" id="gameOverTitle"></div>
      <div class="score-text" id="finalScore"></div>
      <button class="btn btn-secondary" onclick="shareScore()">Share High Score</button>
    </div>

    <div id="emailFormBox" class="email-form-box hidden">
      <div class="form-title">Be the first to play Level 2!</div>
      <form class="email-form" onsubmit="submitEmail(event)">
        <input 
          type="email" 
          id="emailInput" 
          class="email-input" 
          placeholder="Enter your email" 
          required
        />
        <button type="submit" class="btn btn-primary">Notify Me!</button>
      </form>
    </div>

    <div id="successBox" class="success-box hidden">
      âœ“ Thanks! We'll notify you when Level 2 is ready!
    </div>

    <div class="instructions">
      <div class="instructions-title">How to Play:</div>
      <p>â€¢ Move mouse to aim, click to shoot</p>
      <p>â€¢ Match 3+ of the same clothing to pop them</p>
      <p>â€¢ Clear floating items for bonus points!</p>
    </div>

    <canvas id="gameCanvas" width="400" height="500"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 500;
    const BUBBLE_RADIUS = 20;
    const SHOOTER_Y = CANVAS_HEIGHT - 60;
    const COLS = 9;
    const ROW_OFFSET_Y = 35;

    const clothingEmojis = ['ðŸ‘•', 'ðŸ©³', 'ðŸ‘—'];

    let gameState = {
      bubbles: [],
      shooter: { x: CANVAS_WIDTH / 2, y: SHOOTER_Y, angle: Math.PI / 2 },
      currentClothing: null,
      nextClothing: null,
      projectile: null,
      animating: false
    };

    let score = 0;
    let highScore = 0;
    let gameOver = false;

    function getRandomClothing() {
      if (!gameState.bubbles || gameState.bubbles.length === 0) {
        return clothingEmojis[Math.floor(Math.random() * clothingEmojis.length)];
      }
      
      const availableTypes = [...new Set(gameState.bubbles.map(b => b.clothing))];
      
      if (availableTypes.length === 0) {
        return clothingEmojis[Math.floor(Math.random() * clothingEmojis.length)];
      }
      
      return availableTypes[Math.floor(Math.random() * availableTypes.length)];
    }

    function initializeGame() {
      const bubbles = [];
      const rows = 8;
      
      for (let row = 0; row < rows; row++) {
        const cols = row % 2 === 0 ? COLS : COLS - 1;
        for (let col = 0; col < cols; col++) {
          const x = col * (BUBBLE_RADIUS * 2) + BUBBLE_RADIUS + (row % 2 === 1 ? BUBBLE_RADIUS : 0);
          const y = row * (BUBBLE_RADIUS * 1.73) + ROW_OFFSET_Y;
          bubbles.push({
            x,
            y,
            clothing: clothingEmojis[Math.floor(Math.random() * clothingEmojis.length)],
            row,
            col
          });
        }
      }

      gameState = {
        bubbles,
        shooter: { x: CANVAS_WIDTH / 2, y: SHOOTER_Y, angle: Math.PI / 2 },
        currentClothing: getRandomClothing(),
        nextClothing: getRandomClothing(),
        projectile: null,
        animating: false
      };

      score = 0;
      gameOver = false;
      updateScore();
      
      document.getElementById('gameOverBox').classList.add('hidden');
      document.getElementById('emailFormBox').classList.add('hidden');
      document.getElementById('successBox').classList.add('hidden');
    }

    function findConnectedBubbles(bubbles, startBubble) {
      const connected = new Set();
      const toCheck = [startBubble];
      const clothing = startBubble.clothing;

      while (toCheck.length > 0) {
        const current = toCheck.pop();
        const key = `${current.x},${current.y}`;
        
        if (connected.has(key)) continue;
        connected.add(key);

        const neighbors = bubbles.filter(b => {
          if (b.clothing !== clothing) return false;
          const dist = Math.sqrt((b.x - current.x) ** 2 + (b.y - current.y) ** 2);
          return dist < BUBBLE_RADIUS * 2.5 && dist > 0;
        });

        toCheck.push(...neighbors.filter(n => !connected.has(`${n.x},${n.y}`)));
      }

      return Array.from(connected).map(key => {
        const [x, y] = key.split(',').map(Number);
        return bubbles.find(b => b.x === x && b.y === y);
      });
    }

    function findFloatingBubbles(bubbles) {
      const attached = new Set();
      const toCheck = bubbles.filter(b => b.row === 0);
      
      toCheck.forEach(b => attached.add(`${b.x},${b.y}`));

      let added = true;
      while (added) {
        added = false;
        bubbles.forEach(bubble => {
          const key = `${bubble.x},${bubble.y}`;
          if (attached.has(key)) return;

          const hasAttachedNeighbor = bubbles.some(b => {
            if (!attached.has(`${b.x},${b.y}`)) return false;
            const dist = Math.sqrt((b.x - bubble.x) ** 2 + (b.y - bubble.y) ** 2);
            return dist < BUBBLE_RADIUS * 2.5 && dist > 0;
          });

          if (hasAttachedNeighbor) {
            attached.add(key);
            added = true;
          }
        });
      }

      return bubbles.filter(b => !attached.has(`${b.x},${b.y}`));
    }

    function snapToGrid(x, y, bubbles) {
      let minDist = Infinity;
      let snapPos = { x, y, row: 0, col: 0 };

      for (let row = 0; row < 20; row++) {
        const cols = row % 2 === 0 ? COLS : COLS - 1;
        for (let col = 0; col < cols; col++) {
          const gridX = col * (BUBBLE_RADIUS * 2) + BUBBLE_RADIUS + (row % 2 === 1 ? BUBBLE_RADIUS : 0);
          const gridY = row * (BUBBLE_RADIUS * 1.73) + ROW_OFFSET_Y;
          const dist = Math.sqrt((gridX - x) ** 2 + (gridY - y) ** 2);

          if (dist < minDist && !bubbles.some(b => Math.abs(b.x - gridX) < 5 && Math.abs(b.y - gridY) < 5)) {
            minDist = dist;
            snapPos = { x: gridX, y: gridY, row, col };
          }
        }
      }

      return snapPos;
    }

    function updateScore() {
      document.getElementById('score').textContent = score;
      document.getElementById('highScore').textContent = highScore;
    }

    function updateGame() {
      if (gameState.projectile && !gameState.animating) {
        gameState.projectile.x += gameState.projectile.vx;
        gameState.projectile.y += gameState.projectile.vy;

        if (gameState.projectile.x - BUBBLE_RADIUS < 0 || gameState.projectile.x + BUBBLE_RADIUS > CANVAS_WIDTH) {
          gameState.projectile.vx *= -1;
          gameState.projectile.x = gameState.projectile.x < CANVAS_WIDTH / 2 ? BUBBLE_RADIUS : CANVAS_WIDTH - BUBBLE_RADIUS;
        }

        const hitBubble = gameState.bubbles.find(b => {
          const dist = Math.sqrt((b.x - gameState.projectile.x) ** 2 + (b.y - gameState.projectile.y) ** 2);
          return dist < BUBBLE_RADIUS * 2;
        });

        if (gameState.projectile.y - BUBBLE_RADIUS < ROW_OFFSET_Y || hitBubble) {
          gameState.animating = true;
          
          const snapPos = snapToGrid(gameState.projectile.x, gameState.projectile.y, gameState.bubbles);
          const newBubble = {
            x: snapPos.x,
            y: snapPos.y,
            clothing: gameState.projectile.clothing,
            row: snapPos.row,
            col: snapPos.col
          };

          gameState.bubbles.push(newBubble);

          const connected = findConnectedBubbles(gameState.bubbles, newBubble);
          
          if (connected.length >= 3) {
            gameState.bubbles = gameState.bubbles.filter(b => !connected.some(c => c.x === b.x && c.y === b.y));
            score += connected.length * 10;
            updateScore();

            const floating = findFloatingBubbles(gameState.bubbles);
            gameState.bubbles = gameState.bubbles.filter(b => !floating.some(f => f.x === b.x && f.y === b.y));
            score += floating.length * 10;
            updateScore();
          }

          const maxY = Math.max(...gameState.bubbles.map(b => b.y), 0);
          if (maxY > CANVAS_HEIGHT - 150) {
            endGame(false);
          }

          if (gameState.bubbles.length === 0) {
            endGame(true);
          }

          gameState.projectile = null;
          gameState.currentClothing = gameState.nextClothing;
          gameState.nextClothing = getRandomClothing();
          gameState.animating = false;
        }
      }
    }

    function endGame(won) {
      gameOver = true;
      
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('laundryGameHighScore', highScore.toString());
        updateScore();
      }

      const gameOverBox = document.getElementById('gameOverBox');
      const gameOverTitle = document.getElementById('gameOverTitle');
      const finalScore = document.getElementById('finalScore');

      gameOverTitle.textContent = won ? 'Level 1 Complete!' : 'Game Over!';
      finalScore.textContent = `Final Score: ${score}`;
      
      gameOverBox.className = won ? 'message-box win' : 'message-box lose';
      gameOverBox.classList.remove('hidden');

      if (won) {
        document.getElementById('emailFormBox').classList.remove('hidden');
      }
    }

    function draw() {
      ctx.fillStyle = '#f0f4ff';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      if (!gameState.projectile) {
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(gameState.shooter.x, gameState.shooter.y);
        ctx.lineTo(
          gameState.shooter.x + Math.cos(gameState.shooter.angle) * 300,
          gameState.shooter.y - Math.sin(gameState.shooter.angle) * 300
        );
        ctx.stroke();
        ctx.setLineDash([]);
      }

      gameState.bubbles.forEach(bubble => {
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(bubble.x, bubble.y, BUBBLE_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(bubble.clothing, bubble.x, bubble.y);
      });

      if (gameState.projectile) {
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(gameState.projectile.x, gameState.projectile.y, BUBBLE_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(gameState.projectile.clothing, gameState.projectile.x, gameState.projectile.y);
      }

      ctx.fillStyle = '#6366f1';
      ctx.beginPath();
      ctx.arc(gameState.shooter.x, gameState.shooter.y, BUBBLE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.font = '28px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(gameState.currentClothing, gameState.shooter.x, gameState.shooter.y);

      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(CANVAS_WIDTH - 50, CANVAS_HEIGHT - 40, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.font = '20px Arial';
      ctx.fillText(gameState.nextClothing, CANVAS_WIDTH - 50, CANVAS_HEIGHT - 40);
      
      ctx.font = '12px Arial';
      ctx.fillStyle = '#666';
      ctx.fillText('Next:', CANVAS_WIDTH - 50, CANVAS_HEIGHT - 65);
    }

    canvas.addEventListener('mousemove', (e) => {
      if (gameOver || gameState.projectile) return;
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const dx = mouseX - gameState.shooter.x;
      const dy = gameState.shooter.y - mouseY;
      let angle = Math.atan2(dy, dx);
      
      angle = Math.max(Math.PI * 0.1, Math.min(Math.PI * 0.9, angle));
      
      gameState.shooter.angle = angle;
    });

    canvas.addEventListener('click', () => {
      if (gameOver || gameState.projectile) return;

      const speed = 8;
      
      gameState.projectile = {
        x: gameState.shooter.x,
        y: gameState.shooter.y,
        vx: Math.cos(gameState.shooter.angle) * speed,
        vy: -Math.sin(gameState.shooter.angle) * speed,
        clothing: gameState.currentClothing
      };
    });

    function newGame() {
      initializeGame();
    }

    function shareScore() {
      const shareText = `I just scored ${score} points in Laundry! The Game! Can you beat my score?`;
      
      if (navigator.share) {
        navigator.share({
          title: 'Laundry! The Game',
          text: shareText,
        }).catch(() => {});
      } else {
        navigator.clipboard.writeText(shareText);
        alert('Score copied to clipboard!');
      }
    }

    function submitEmail(e) {
      e.preventDefault();
      const email = document.getElementById('emailInput').value;
      console.log('Email submitted:', email);
      
      document.getElementById('emailFormBox').classList.add('hidden');
      document.getElementById('successBox').classList.remove('hidden');
    }

    // Load high score
    const savedHighScore = localStorage.getItem('laundryGameHighScore');
    if (savedHighScore) {
      highScore = parseInt(savedHighScore, 10);
    }

    initializeGame();

    setInterval(() => {
      updateGame();
      draw();
    }, 1000 / 60);
  </script>
</body>
</html>
